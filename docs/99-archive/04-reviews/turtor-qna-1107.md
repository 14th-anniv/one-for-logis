> **Q.  🙋🏻‍♀️**
>
1. 현재 각 서비스 모듈이 공통 모듈(common-lib)을 의존해서 예외처리 시 CustomException, ErrorCode 등을 그대로 사용하고 있습니다.
   그런데 도메인 내부에서 발생하는 규칙 위반(ex. 비즈니스 제약, 상태 전이 불가 등)을 다룰 때 각 서비스 모듈 내에 domain.exception , application.exception 패키지를 별도로 만들어 예외 클래스를 개별 정의하는 게 좋을지 고민입니다.
   이런 예외 들을 따로 두는 게 좋을까요? 만약 그렇게 한다면 공통 모듈의 ErrorCode는 인증 같은 전역 공통 오류만 남기고, 각 서비스 별 비즈니스 관련 에러 메시지는 제거하는 것인지 궁금합니다!
2.  DTO에서 @Valid, @NotBlank 등을 이용해 입력 값 검증을 하고 있습니다. 도메인 엔티티 내부에서도 “이름은 비어 있을 수 없습니다” 같은 규칙 검증이 필요하다고 DDD 특강에서 이해했는데요! 이 경우 DTO와 도메인에서 같은 검증 로직이 중복되는 게 자연스러운 건가요? 아니면 둘 중 한쪽에만 둘 수도 있을까요?_? 도메인 필드가 많아질수록 검증 로직이 많아질 텐데, 이런 부분은 일반적으로 어떻게 관리하는지도 궁금합니다.
3. 지금 구조에서는 presentation 계층에만 DTO를 두고 있는데, 달님 반에 공유되어있는 ppt 자료에서는 단일 클라이언트일 때 선택 시 application 계층 쪽에 dto를 두어도 된다고 되어있어서요.
   클라이언트 구분을 '요청, 응답 포맷이 다르다'로 보는 거라고 이해했습니다. 지금 프로젝트처럼 관리자/허브/업체 등 권한 별로 접근 가능한 리소스만 다르고 api 포맷은 동일하게 설계할 경우에는 이것을 단일 클라이언트로 보고 계층 별로 dto를 나누지 않고 application req/res dto 하나로 유지해도 될까요?

> **A. 🤓**
>
1. 도메인 규칙 위반과 같은 비즈니스 예외는 각 서비스 모듈 내부에 `domain.exception` 등을 만들어 별도 정의하는 것을 권장드려요! 공통 모듈의 ErrorCode는 인증/인가, 서버 오류 등 전역적인 공통 오류만 남겨두는 것이 좋습니다. 비즈니스 관련 에러 메시지는 각 서비스 모듈 내부에 별도로 정의하여 관리하면 좋아요
2. DTO와 도메인 엔티티 모두에서 검증 로직이 중복되는 것은 자연스럽습니다. 검증의 목적이 다르기 때문이에요
3. 현재 프로젝트처럼 관리자/허브/업체 등 **권한만 다르고 API 포맷이 동일**하게 설계할 경우, 이는 **단일 클라이언트 유형**으로 볼 수 있어요! 따라서 Presentation 계층과 Application 계층 간의 DTO를 나누지 않고, Application 계층에 단일 request DTO, response DTO 세트를 두고 유지하는 것이 효율적입니다. 클라이언트 구분을 '요청, 응답 포맷이 다르다'로 보는 것이 맞을 거 같아요!

---

🤔🤔🤔

- 가능하다면 예외처리도 리팩토링 → (서비스 별 ErrorCode 파일을 따로 만들어 안 쪽에 다 넣을 지, 익셉션 파일로 하나씩 둘 지는 선택일 거 같습니다.)
- 이 전 튜터님께서도 원칙적으로는 dto를 계층별 분리 하고 사용하는 게 맞다고 하셨지만, 축약하고 싶은 경우에는 응용 계층에 서비스 dto를 두고 컨트롤러 쪽에서 이를 참조하게 하는 것도 방법이라고 하셨기 때문에 **응용 계층으로 dto를 옮기는 게 좋을 거 같습니다**. (현재 presentation에 dto 위치)

(+)

1. **DTO 검증 vs 도메인 검증**

좋은 질문인 것 같습니다,  표현/응용 계층에서의 입력값 검증과 도메인 내부 검증은 목적이 다릅니다.

- **DTO 검증**은 주로 도메인 로직 실행에 필요한 **입력 데이터의 유효성 및 외부 데이터 무결성**을 확인하는 것이 목적입니다.
- 예: `@NotBlank`, `@Size` 등을 통해 “값이 존재하는가?”, “형식이 맞는가?” 등을 확인
- **도메인 검증**은 도메인 모델이 항상 유효한 상태를 유지하도록 **불변식(invariant)**을 보장하는 것이 목적입니다.

예: “비밀번호는 반드시 회사 정책에 맞는 패턴이어야 한다”, “회사는 삭제된 상태에서 다시 활성화될 수 없다” 등 예를 들어 “비밀번호 변경” 유즈케이스를 생각해보면, 입력값의 존재 여부는 DTO 검증으로,비밀번호의 복잡도나 정책 적합성은 도메인 계층에서 검증하는 것이 올바른 접근입니다.

---

**3. 단일 클라이언트 환경의 DTO 구조**

말씀하신 내용이 정확합니다. 관리자 / 허브 / 업체 등 **권한별 접근 리소스만 다르고 요청·응답 포맷이 동일하다면**,하나의 DTO로 통합해 사용하는 것도 충분히 좋은 선택입니다.즉, 클라이언트 구분을 “요청/응답 포맷의 차이”로 본다면, 이 경우에는 “단일 클라이언트”로 간주할 수 있고,DTO를 `application` 계층에만 두는 간결한 구조로 유지해도 괜찮습니다.단, 권한별 접근 제어나 인증·인가 로직은 `Controller`나 `Service` 단의 **Security/Authorization 레이어**에서 처리해 주시면 됩니다.
