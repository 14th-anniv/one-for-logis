## 2️⃣ **물류 관리 및 배송 시스템을 위한 MSA 기반 플랫폼 개발**

- 이전 프로젝트에서는 실생활에서 쉽게 접할 수 있는 주문 관리 플랫폼을 개발해 보았습니다. 
이번에는 **물류 관리 및 배송 시스템**을 개발하는 것이 목표입니다. 
이 과정에서 우리는 MSA(Microservices Architecture) 기반의 시스템을 설계하고 구현하면서, 다양한 기술과 방법론을 적용해 볼 예정입니다.
- 실무에서는 개발자 간의 협업이 필수적이며, 서로 다른 애플리케이션 간의 데이터 연동과 기능 요청이 빈번하게 발생합니다. 강의를 통해 MSA의 핵심 기능과 데이터를 효율적으로 관리하는 방법을 학습했으니, 
이번 프로젝트에서는 팀원들과 함께 MSA 애플리케이션을 구성하고 서로 호출하면서 협력할 것입니다. 이를 통해 실무에서 발생할 수 있는 다양한 상황을 경험해 볼 수 있을 것입니다.
- MSA를 개발할 때는 많은 고민이 필요합니다. 예를 들어, 하나의 서비스에서 변경이 발생할 때 전체 시스템에 미칠 영향을 신중하게 고려해야 합니다. API의 스펙을 변경할 경우, 이로 인해 발생할 수 있는 문제들을 어떻게 최소화할지 생각해야 합니다. 
이 프로젝트에서는 API 연동, 데이터 무결성 유지, 그리고 서비스 간 통신의 신뢰성을 확보하는 방법에 대해 집중적으로 고민하고, Spring Cloud와 Spring Boot를 활용하여 이러한 과제들을 해결할 방안을 모색할 것입니다.
- 특히, 이번 프로젝트에서는 Gemini API를 사용하여 간접적으로 AI를 활용하는 경험도 쌓을 것입니다. 
특정 기능을 AI를 이용해 구현하며, AI 기술을 실제 프로젝트에 어떻게 적용할 수 있는지를 고민해 볼 수 있을 것입니다.
- 이번 프로젝트를 통해 **MSA의 복잡성을 이해**하고, **팀원들과 함께 MSA를 구축하며 실무에서 발생할 수 있는 문제를 간접적으로 경험하고 해결하는 것**이 목표입니다. 
이러한 경험이 향후 더 나은 시스템을 설계하고 개발하는 데 큰 도움이 될 것입니다.

## 3️⃣ 개발 프로세스 가이드

- 1단계 프로젝트 킥오프
    - 주제
        - MSA 기반 국내 물류 관리 및 배송 시스템 개발 ( 스파르타 물류 )
    - 개요
        - 이번 프로젝트는 B2B 물류 관리 및 배송 시스템 입니다. B2B는 Business to Business의 약자로, 기업 간 거래를 의미합니다.
        - 스파르타 물류는 각 지역에 허브센터를 가지고 있으며 각 허브 센터는 여러 업체의 물건을 보관합니다.
        - 허브의 재고가 부족할 경우, 공급업체로부터 상품이 입고됩니다
        (이 과정은 본 시스템의 개발 범위에 포함되지 않으므로 별도로 구현하거나 고려하지 않아도 됩니다.)
        - 해당 상품의 배송 요청이 들어오면 목적지 허브로 물품을 이동시켜 목적지에 배송합니다.
        - 예를 들어 아래와 같은 프로세스가 진행됩니다.
            - **시스템의 구조**
                - **도별 공급 허브**: 시스템은 허브를 가지고 있으며, 이 허브는 해당 도 내의 모든 주문, 재고 관리, 물류 운영을 담당합니다.
            - **건조 식품 가공 업체(예시 업체)의 역할:**
                - **경기도 일산의 건조 식품 가공 업체**: 이 업체는 경기도에 위치한 건조 식품 가공품 생산 업체입니다.
            - **주문 발생:**
                - **부산시의 수산물 도매 업체(예시 업체)**: 부산에 위치한 수산물 도매 업체는 스파르타 물류로 연락하여 50개의 마른오징어 가공품을 주문합니다.
                - 이에 따라 스파르타 물류는 허브에 저장된 가공품의 배송을 합니다.
            - **물류 처리 및 재고 이동:**
                - **경기도 허브에서 부산시 허브로 물품 이동**: 시스템은 주문을 처리하기 위해, 경기도 허브에 저장된 플라스틱 가공품을 부산시 허브로 이동 시키도록 계획합니다. 이 과정에서 허브 배송 담당자를 통해 이동 경로에 따라, 부산시 허브로 물품이 안전하게 전달됩니다.
            - **최종 수령:**
                - **부산시 허브에서 수산물 도매 업체로 물품 전달**: 부산시 허브에 물품이 도착하면, 부산 허브 소속 업체 배송담당자가 물품을 주문한 수산물 도매 업체로 배송 합니다.
                
                ![서비스플로우3.png](attachment:f663a8f9-96fb-4a06-b5cb-a6c77cad75f0:서비스플로우3.png)
                
- 2단계 요구사항 확인
    - 허브 관리 (필수 과제)
        - 허브 위치 :
            - 스파르타 물류는 아래와 같은 위치에 허브를 보유하고 있습니다:
                - 서울특별시 센터 : 서울특별시 송파구 송파대로 55
                - 경기 북부 센터 : 경기도 고양시 덕양구 권율대로 570
                - 경기 남부 센터 : 경기도 이천시 덕평로 257-21
                - 부산광역시 센터 : 부산 동구 중앙대로 206
                - 대구광역시 센터 : 대구 북구 태평로 161
                - 인천광역시 센터 : 인천 남동구 정각로 29
                - 광주광역시 센터 : 광주 서구 내방로 111
                - 대전광역시 센터 : 대전 서구 둔산로 100
                - 울산광역시 센터 : 울산 남구 중앙로 201
                - 세종특별자치시 센터 : 세종특별자치시 한누리대로 2130
                - 강원특별자치도 센터 : 강원특별자치도 춘천시 중앙로 1
                - 충청북도 센터 : 충북 청주시 상당구 상당로 82
                - 충청남도 센터 : 충남 홍성군 홍북읍 충남대로 21
                - 전북특별자치도 센터 : 전북특별자치도 전주시 완산구 효자로 225
                - 전라남도 센터 : 전남 무안군 삼향읍 오룡길 1
                - 경상북도 센터 : 경북 안동시 풍천면 도청대로 455
                - 경상남도 센터 : 경남 창원시 의창구 중앙대로 300
    - 허브간 이동정보 **관리
        - **데이터 조회** :
            - 허브 간 이동 정보는 `허브간 이동정보 관리(필수기능가이드)` 에 따라 허브 간 경로가 매핑 되어 있습니다.
    - 배송 담당자 관리
        - **업체 배송 담당자 구성** :
            - 업체 배송 담당자는 각 허브에 소속되어 있으며, 각 허브 별로 10명의 업체 배송 담당자가 있습니다.
        - **허브 배송 담당자 구성 :**
            - 허브 배송 담당자는 물류 시스템 전체에서 총 10명이 존재합니다. 
            각 담당자의 업무 수행 시 시간 또는 공간적 제약은 고려하지 않습니다
        - **배송 담당자 타입**:
            - 배송 담당자는 허브 배송 담당자와 업체 배송 담당자로 나뉘며, 두 타입 간의 업무는 명확히 구분됩니다.
            
            | 분류 | 정의  | 인원 수 |
            | --- | --- | --- |
            | 허브 배송 담당자 | 허브 간 이동을 담당 | 스파르타 물류에 10명 존재
            ~~~~ |
            | 업체 배송 담당자  | 최종 허브에서 수령 업체 까지의 이동을 담당 | 각 허브당 10명 존재 |
    - **업체 관리**
        - **업체 소속**
            - 모든 업체는 특정 허브에 소속되어 있습니다.
        - **업체 타입** :
            - 업체는 **생산업체**와 **수령업체**로 구분됩니다.
    - **상품 관리**
        - **상품 소속** :
            - 모든 상품은 특정 업체와 허브에 소속되어 있습니다.
    - **주문 관리**
        - **주문 생성 및 취소** :
            - 주문이 생성되면 관련된 재고가 감소하며, 주문이 취소되면 해당 수량이 복원됩니다.
            - 허브에 물품 재고가 없는 경우는 주문이 실패해야 합니다.
            - 주문이 삭제 되면 연관된 데이터는 deleted_by, deleted_at 필드를 통해 관리됩니다.
    - **배송 관리**
        - **배송 데이터** :
            - 배송 및 배송 경로 기록 엔티티는 주문 생성 시 함께 생성되며, 연관된 데이터는 deleted_by, deleted_at 필드를 통해 관리됩니다.
    - **슬랙 메시지 관리**
        - **슬랙 메시지 발송** :
            - 모든 슬랙 메시지는 슬랙 메시지 엔티티에 저장됩니다.
            - 로그인한 모든 사용자 및 내부 시스템에서 메시지 발송이 가능합니다.
    - **사용자 관리**
        - **사용자 정보 관리**:
            - 사용자 엔티티는 모든 사용자 정보를 관리하며, 사용자 비활성화 시 deleted_by, deleted_at 필드를 통해 관리됩니다.
        - **권한**:
            
            
            | 분류 | 설명 |
            | --- | --- |
            | 마스터 관리자 | 모든 기능에 대한 권한이 있는 관리자 입니다. |
            | 허브 관리자 | 담당하는 허브를 관리합니다. 
            허브에 속한 배송 담당자를 관리할 수 있습니다.
            허브에 속한 업체를 관리할 수 있습니다. |
            | 배송 담당자 | 허브 배송 담당자: 허브 간 배송을 담당합니다. 허브 → 업체 배송은 불가능 합니다.
            업체 배송 담당자: 허브 → 업체 배송을 담당합니다. 허브 간 배송은 불가능 합니다. |
            | 업체 담당자 | 소속된 업체 정보를 관리합니다.
            업체가 등록한 상품을 관리할 수 있습니다. |
    - **기타 공통 사항**
        - **논리적 삭제 관리**:
            - 모든 엔티티에서 deleted_by, deleted_at 필드를 추가하여 논리적 삭제를 관리하며, deleted_at 필드가 null인 데이터만 조회 및 검색에서 사용되도록 로직을 구현합니다.
        - **API 호출 기반 연동**:
            - MSA 환경에서 API 호출을 통해 서비스 간 데이터 연관성을 유지하며, 데이터 변경 시 이를 반영하는 통신 구조를 설계합니다.
        - **트랜잭션 관리**:
            - 여러 엔티티가 동시에 업데이트될 경우 트랜잭션을 사용하여 일관성을 유지하며, 실패 시 전체를 롤백 처리합니다.
    - 개발 요구사항
        - **MSA 기반 아키텍처:**
            - 모든 주요 기능은 독립적인 마이크로서비스로 개발되어, 각각의 서비스가 독립적으로 배포, 확장, 유지보수될 수 있도록 설계합니다. 다만, 모든 서비스를 MSA로 구성할 필요는 없습니다.
        - **서비스 간 통신:**
            - 서비스 간의 통신은 주로 REST API를 통해 이루어집니다. FeignClient를 이용하는 걸 기본 구성으로 권장합니다.
        - **인프라 확장:**
            - 시스템 설계는 간결하게 하며 각 MSA 애플리케이션은 수평 확장 될 수 있습니다.
        - 기술 스택
            - **백엔드:** Spring Boot 3.x
            - **데이터베이스:** PostgreSQL 를 권고 드리나, 다른 데이터베이스를 이용하셔도 무방합니다.
            - **빌드 툴:**  Gradle
            - **API 문서화:** 프론트 엔드 개발자가 API 문서만 보고도 개발 할 수 있게 작성하고*,* Swagger 등의 API 문서 자동화 라이브러리를 이용하여 문서 관리를 진행합니다.
            - **API 게이트웨이:** Spring Cloud Gateway를 사용하여 모든 외부 요청을 각 마이크로서비스로 라우팅 합니다.
            - **서비스 디스커버리:** Spring Cloud Eureka를 사용하여 각 마이크로서비스의 위치를 자동으로 발견하고 관리하도록 합니다.
            - **버전 관리:** Git을 이용한 버전 관리 (GitHub, GitLab, Bitbucket 등)
        - **프로젝트 구조**
            - **Layered Architecture:** Controller, Service, Domain 계층으로 구성된 클린 아키텍처 권장드리며 DDD 적용을 위한 패키징 개념도 포함될 수 있습니다.
                - *(패키지 구조 샘플)*
                    
                    https://github.com/DongwooSeo/ddd-examples
                    
                    ```java
                    com.example.myapp
                    ├── application
                    │   ├── service
                    │   │   ├── OrderService.java
                    │		│		├── UserService.java
                    │   │   └── OrderMessageService.java
                    │   ├── dto
                    │   │   └── OrderDTO.java
                    ├── domain
                    │   ├── model
                    │   │   ├── Order.java
                    │   │   ├── Product.java
                    │   │   └── ValueObject.java
                    │   ├── repository
                    │   │   └── OrderRepository.java
                    │   └── service
                    │       └── OrderDomainService.java
                    ├── infrastructure
                    │   ├── repository
                    │   │   ├── JpaOrderRepository.java
                    │   │   ├── OrderRepositoryImpl.java
                    │   │   └── OrderQueryDSLRepositoryImpl.java
                    │   ├── client
                    │   │   └── UserClient.java
                    │   ├── configuration
                    │   │   └── DatabaseConfig.java
                    │   └── messaging
                    │				├──	OrderMessageConsumer.java
                    │       └── OrderMessageProducer.java
                    │
                    └── presentation
                        ├── controller
                        │   └── OrderController.java
                        └── request
                            └── OrderRequest.java
                    
                    ```
                    
                    - `OrderRepository` 와 `JpaOrderRepository` 가 왜 따로있나요 ?
                        
                        ### **도메인 계층은 비즈니스 로직을 담당하는 곳입니다.**
                        
                        `JpaRepository`는 JPA의 QueryMethod, JPQL, NativeQuery 같은 특정 기술을 사용하기 때문에, DDD의 관점에서는 **도메인을 벗어난 외부 환경 요소**에 해당합니다.
                        
                        만약 도메인 계층이 JPA에 직접 의존하면, 향후 JPA가 아닌 다른 기술을 도입할 경우 도메인 계층까지 변경해야 하는 문제가 발생할 수 있습니다.
                        
                        따라서, 비즈니스 로직 내에서는 `JpaRepository`를 직접 사용하지 않고, 도메인 계층에서는 데이터 접근 방식만 정의하는 인터페이스(`OrderRepository`)를 두어 도메인의 독립성을 가져갈 수 있습니다.
                        
                        그리고 JPA를 사용하는 구체적인 구현체(`JpaOrderRepository`)는 **Infrastructure 계층**으로 분리하여 관리하는 것이 올바른 설계 방식입니다.
                        
                        ![계층간 요소에 대한 예시 이미지](attachment:9aa32133-d1ea-48af-9d9b-a292b3d7184b:제목_없는_다이어그램.drawio_(1).png)
                        
                        계층간 요소에 대한 예시 이미지
                        
                    - `UserService` 와 `UserClient` 의 차이는 무엇인가요 ?
                        
                        MSA 환경에서 `Order` 서비스의 입장에서는 `User` 서비스는 비즈니스 내부가 아니라 외부 서비스로 간주되므로, `User`와 관련된 설정은 `Infrastructure` 계층에 두는 것이 적합합니다.
                        
                        여기서 문제는, 만약 `OrderService`가 `Infrastructure`에 위치한 `UserService`를 직접 사용하게 되면 Layered Architecture 원칙에 위배된다는 점입니다. 
                        
                        이를 해결하기 위해, `UserService`는 인터페이스로 정의하고, 
                        실제 FeignClient 와 관련된 로직은 `UserClient`라는 별도의 파일로 분리하는 것이 좋습니다. 
                        
            - **Entity 및 DTO:** 각 기능별로 Entity와 DTO(Data Transfer Object)를 분리하여 관리
            - **API 설계:** RESTful API 원칙에 따라 설계
            - **도메인 주도 설계(DDD)**: 마이크로서비스는 보통 비즈니스 도메인에 맞춰 분리됩니다. 따라서 요구사항을 바탕으로 각 도메인과 마이크로서비스의 경계를 정의하는 것이 중요합니다.
            - **서비스 경계 결정**: 각 마이크로서비스가 어떤 기능을 담당할지, 어떤 서비스 단위로 분리할지 고민해야 합니다.
        - 데이터베이스
            - **테이블 명명 규칙:** 모든 테이블에 p_ 접두사 사용
            - **UUID 사용:** postgres의 경우, 모든 주요 엔티티의 식별자는 UUID를 사용 (유저는 예외) 그 외 데이터베이스는 자율로 구성
            - **분산 데이터베이스:** 마이크로서비스별로 논리적 또는 물리적으로 독립된 데이터베이스를 사용하며, 필요한 경우 분산 데이터베이스 및 데이터 복제를 적용하여 가용성과 성능을 보장합니다.
            - **Audit 필드:** 모든 테이블에 created_at, created_by, updated_at, updated_by, deleted_at, deleted_by 필드를 추가하여 데이터 감사 로그 기록
        - 보안
            - **JWT 인증:** Spring Security와 JWT(Json Web Token)를 이용한 인증 및 권한 관리
            - **권한 확인:** 권한은 요청마다 저장되어 있는 권한 값과 동일한지 체크필요
            - **비밀번호 암호화:** BCrypt 해시 알고리즘을 사용한 비밀번호 암호화
            - **데이터 유효성 검사:** 서버 측 데이터 유효성 검사를 위해 Spring Validator 사용
- 3단계 테이블 명세서 및 ERD 작성
    - **ERD 설계:** 각 마이크로서비스별로 ERD(Entity-Relationship Diagram)를 작성하여, 데이터베이스의 구조와 관계를 명확히 정의합니다.
    - 각 MSA에 연결된 데이터 베이스 별로 테이블 명세서를 작성해주세요. 아래는 유저 테이블 예시 입니다.
        
        ### 1. **사용자 테이블 (`p_users`)**
        
        | 필드 이름 | 데이터 타입 | 설명 |
        | --- | --- | --- |
        | `username` | `VARCHAR(100)` | 사용자 ID, Primary Key |
        | `nickname` | `VARCHAR(100)` | 사용자 닉네임 |
        | `email` | `VARCHAR(255)` | 사용자 이메일, Unique |
        | `password` | `VARCHAR(255)` | 사용자 비밀번호 |
        | `role` | `role_type` | 사용자 역할 (`MASTER`, `HUB_MANAGER`, `DELIVERY_MANAGER`, `SUPPLIER_MANAGER`) |
        | `is_public` | `BOOLEAN` | 사용자 정보가 공개된 상태인지 여부, 기본값 `TRUE` |
        | `created_at` | `TIMESTAMP` | 레코드 생성 시간 |
        | `created_by` | `VARCHAR(100)` | 레코드 생성자 (username) |
        | `updated_at` | `TIMESTAMP` | 레코드 수정 시간 |
        | `updated_by` | `VARCHAR(100)` | 레코드 수정자 (username) |
        | `deleted_at` | `TIMESTAMP` | 레코드 삭제 시간 |
        | `deleted_by` | `VARCHAR(100)` | 레코드 삭제자 (username) |
    - 각 서비스가 독립적으로 동작하므로, 서비스마다 별도의 데이터베이스 혹은 데이터베이스 스키마를 설계하는 것이 일반적입니다.(이번에는 스키마를 분리하도록 합니다)
        
        ![image.png](attachment:c0e78c12-d18f-4172-b48b-445e7d26dbfc:image.png)
        
        ![스키마.png](attachment:098af944-a62a-41c9-97b9-ec0facb85919:스키마.png)
        
        - 서동우 튜터님 : [[251024] DDD 세션](https://www.notion.so/251024-DDD-2992dc3ef5148043a6e6d4d5976bd598?pvs=21)
- 4단계 인프라 설계도 작성
    - 각 마이크로서비스의 특성과 요구사항에 따라 필요한 인프라 요소를 결정합니다. 예를 들어, 서비스 간의 통신 방식, 데이터 저장소, 메시지 브로커, API 게이트웨이등을 포함합니다.
    - https://app.diagrams.net/ 를 사용하여 인프라의 설계도를 작성해봅니다. 아래는 예시 설계도 입니다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/94c6c431-0dbb-4f6d-8533-cdccd0dfc90b/image.png)
        
    - 인프라 설계도는 타 개발자들에게 서비스 개발을 효과적으로 설명 할 수 있는 요소입니다.
    - 쉬운 구조라도 반드시 그려보기 바랍니다.
- 5단계 API 명세서 작성
    - 모든 명세서를 작성해주세요 아래는 명세서 작성 예시입니다.
        
        ### **게시물 생성 API (`/posts`)**
        
        | **메서드** | **요청 URL** |
        | --- | --- |
        | POST | http://{SERVER_URL}/api/posts |
        
        ### **Request Header**
        
        | **파라미터** | **타입** | **필수여부** | **설명** |
        | --- | --- | --- | --- |
        | Authorization | String | 필수 | (JWT 토큰, `role`이 `MASTER`여야 함) |
        | Content-Type | String | 필수 | application/json |
        
        ### **Role Requirement**
        
        - **권한:** 이 작업은 `role`이 `MASTER`인 사용자만 수행할 수 있습니다.
        
        ### **Request Elements**
        
        | **파라미터** | **타입** | **필수여부** | **설명** |
        | --- | --- | --- | --- |
        | title | String | 필수 | 제목 |
        | content | String | 필수 | 내용 |
        |  |  |  |  |
        
        ### **요청 예시**
        
        ```json
        POST /api/posts
        Authorization: Bearer jwt_token_string
        Content-Type: application/json
        
        {
          "title": "새로운 포스트",
          "content": "이것은 새로운 포스트의 내용입니다."
        }
        ```
        
        ### **Response Elements**
        
        | **필드** | **타입** | **필수여부** | **설명** |
        | --- | --- | --- | --- |
        | id | Integer | 필수 | 포스트 고유 번호 |
        
        ### **응답 예시**
        
        ```json
        {
          "id": 1
        }
        ```
        
- 6단계 백엔드 개발하기
    - 협업을 위한 룰을 정의합니다.
        - 코드 컨벤션, 브랜치 정책, PR 정책, 협업 방식 등의 우리 팀만의 규칙을 세우고 협업을 진행해 보세요.
            - 남동현 튜터님 : [**[250923] Git & PR(Pull Request) 특강**](https://www.notion.so/250923-Git-PR-Pull-Request-2772dc3ef51480eda401e1858a1c17b6?pvs=21)
        - 코드 리뷰를 통해 우리가 정한 규칙에 어긋나지 않는지, 더 좋은 방법이 있는지 확인하는 시간을 가져보세요.
        - 서로 개발 경험이 다를 수 있어요, 부족하면 도와주고 모르는 부분은 서로 채워줄 수 있는 시간이 되기를 바래요.
        - 문제가 발생하면 문제 상황과 원인, 해결 방법과 개선 효과를 문서로 작성하고 공유해보세요. 간접적인 경험을 통해 서로의 성장에 도움이 되는 동료가 되기를 바래요
    - Spring Boot를 이용하여 본격적인 개발을 진행합니다.
    - CRUD + Search 가 기본임을 항상 생각합니다.
    - 인증 및 인가에 대해 항상 주의 깊게 생각해야 합니다.
    
- 7단계 테스트 및 버그 수정하기
    - **테스트:** 각 마이크로서비스별로 단위 테스트와 통합 테스트를 작성하여, 서비스의 개별 기능을 확인합니다.
    - 작성한 API를 실행해볼 수 있는 테스트 스크립트 혹은 툴을 이용하여 endpoint에서 전체 API를 커버하는 테스트를 자동화합니다. 프로젝트 발표회와 과제 테스트를 위한 방법으로 로컬에서 바로 사용할 수 있도록 준비합니다.

## 4️⃣ 필수 기능 가이드

- MSA 애플리케이션 구성
    - [ ]  유레카 서버를 생성해서 모든 애플리케이션을 관리해주세요.
    - [ ]  게이트웨이를 생성해서 게이트웨이가 모든 인입을 관리하게 해주세요.
    - [ ]  API Gateway에 인증 및 권한 확인 로직을 추가하여 각 서비스로의 요청이 올바르게 인증된 사용자로부터만 이루어지도록 합니다.
    - [ ]  이번 과제는 MSA에 집중하기 위해, 서버 배포 없이 로컬 환경에서 구성하도록 합니다. 모든 애플리케이션을 Docker 컨테이너로 실행해주세요.
        - [ ]  Dockerfile *(혹은 docker-compose)* 파일을 작성하고 컨테이너로 실행후 동작을 확인해주세요.
- 허브 관리
    - [ ]  허브 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 허브 이름, 주소, 위도, 경도
    - [ ]  허브 정보가 자주 변경되지 않으며 반복적으로 조회될 가능성이 있으므로 허브 정보를 캐싱 해주세요.
    - [ ]  허브 엔티티의 CRUD + Search를 구현해 주세요.
    - [ ]  허브 엔티티의 deleted_at, deleted_by를 통해 논리적으로 삭제를 관리합니다. 관련된 서비스에서 API 호출을 통해 해당 허브의 연관 데이터를 처리할 때도 삭제 관련 필드를 기준으로 처리합니다.
    - [ ]  모든 조회 및 검색에서 deleted_at 필드가 null인 데이터만을 대상으로 처리하도록 합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | X | X | X | O |
        | `배송 담당자` | X | X | X | O |
        | `업체 담당자` | X | X | X | O |
        - **생성, 수정, 삭제**: 마스터 관리자만 가능
        - **조회 및 검색**: 모든 로그인 사용자가 가능
- 허브간 이동정보 관리
    - [ ]  허브 간 이동정보 경로를 모델링할 수 있는 엔티티를 생성해주세요. 필수 정보는 다음과 같으며 필요에 따라 추가하거나 변경할 수 있습니다.
        - 출발 허브 ID, 도착 허브 ID, 소요시간, 이동거리
    - [ ]  허브 정보(17개 센터와 해당 주소)는 변경되지 않고 고정됩니다. 경로탐색앱(구글맵, 네이버맵 등) 이나 Gemini 를 활용하여 미리 조회하여 저장해 놓을 수 있습니다.
    - [ ]  허브 간 이동경로는 다음과 같은 모델을 적용할 수 있습니다. 구현 난이도, 제약사항, 설계 적합성 등을 고려하여 해당 팀 프로젝트에 가장 적절한 모델을 선택하시기 바랍니다. (설계에 따라 추가적으로 필요한 엔티티나 필드를 추가할 수 있습니다.)
        - P2P (난이도 `하`)
            
            ![Point-to-Point(P2P)](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/6b694469-60ce-4fba-b745-1ba9db658a12/image.png)
            
            Point-to-Point(P2P)
            
            - **Point-to-Point(P2P)**: 모든 허브가 서로 직접 연결 되어있어, 중간 허브를 경유하지 않고 직접 목적지로 배송합니다. 허브간 배송량이 많거나 긴급한 경우 적합하지만, 허브가 많아 질수록 관리가 복잡해 질 수 있습니다. 주로 빠른 배송이 중요한 전자상거래에서 사용됩니다.
            - 제약사항
                - 모든허브로 **직접 배송**할 수 있습니다. 예를 들어, 서울에서 16개 모든 센터로 직접 배송할 수 있습니다.
        - Hub and Spoke (난이도 `중`)
            
            ![Hub-and-Spoke](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/cd87d91f-feae-49c8-96db-184f5e9f4b85/image.png)
            
            Hub-and-Spoke
            
            - **Hub-and-Spoke**: 모든 허브는 **중앙허브를 통해 연결**되어 있어, 모두 중앙허브를 경유하여 목적지로 배송됩니다. 중앙허브를 공유하므로 효율적인 자원활용(창고, 운송 등)이 가능 하지만, 중앙허브에 의존성이 높으며 이동경로가 비효율적인 경우가 있을 수 있습니다(e.g., 인접 허브간 이동도 중앙허브를 경유하여 전달). 일반적인 택배 및 물류에서 사용됩니다.
            - 제약사항
                - 모든 허브는 3개의 중앙허브(경기남부, 대전광역시, 대구광역시센터)를 거쳐 목적지로 배송합니다.
                    - 서울-부산 배송 시, 서울-경기남부-대구-부산 순으로 배송됩니다.
                    - 세종-서울 배송 시, 세종-대전-경기남부-서울 순으로 배송됩니다.
                - 경기남부, 대전광역시, 대구광역시센터는 중앙허브와 일반허브 역할을 모두 수행합니다.
                - 17개 센터는 아래와 같이 인접한 중앙허브와 연결되어 있습니다.
                    - 경기남부(5): 경기북부, 서울, 인천, 경기남부, 강원도
                    - 대전(7): 충청남도, 충청북도, 세종, 대전, 전라북도, 광주, 전라남도
                    - 대구(5): 경상북도, 대구, 경상남도, 부산, 울산
        - P2P + Hub to Hub Relay (난이도 `중`)
            
            ![P2P + Hub-to-Hub Relay](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/1958b9ae-b4ea-436d-a013-f7e490c28cb7/image.png)
            
            P2P + Hub-to-Hub Relay
            
            - **P2P + Hub-to-Hub Relay**: 기본적으로 인접 허브가 서로 직접 연결 되어있어, 중간 허브를 경유하지 않고 직접 목적지로 배송합니다. **단, 배송거리가 먼 경우에**는 중간 경유지를 통해 릴레이처럼 전달합니다. P2P와 Hub-to-Hub Relay를 혼합한 형태입니다.
            - 제약사항
                - 기본적으로 P2P 동일하게 인접한 허브로 직접 배송할 수 있습니다.
                - 단, 배송거리가 200km 이상인 경우 중간경유지를 통해 배송해야 합니다.예를 들어, 서울-대구(280km) 이동 시 중간 경유지를 추가하여 서울-대전(160km), 대전-대구(120km) 순으로 배송해야 합니다.
                - 효율적으로 배송하기 위한 중간 경유지를 결정하는 알고리즘을 구현해 보시기 바랍니다 (e.g., 출발지와 목적지의 중간에 있는 허브를 중간 경유지로 선택.목적지와 가장 가까운 허브를 중간경유지로 선택).
        - Hub to Hub Relay (난이도 `상`)
            
            ![Hub-to-Hub Relay](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/08934a5d-ea91-46ba-aa0a-eb8d7d603815/image.png)
            
            Hub-to-Hub Relay
            
            - Hub-to-Hub Relay: 각 허브가 인접한 다른 허브와 직접 연결되어 있어, **특정 경로를 통해** 릴레이처럼 전달합니다. 상황에 따라 유연하게 경로를 선택할 수 있는 장점이 있으나 P2P보다 관리가 더 복잡해 질 수 있습니다(e.g., 경로 최적화 알고리즘 필요). 국제물류에서 국가별 허브간 이동에서 사용 됩니다.
            - 제약사항
                - **“연결된”** 허브간 배송만 가능합니다. 예를 들어, 서울-부산 배송시 서울-경기남부-대구-부산 순으로 배송해야 합니다.
                - 17개 센터는 아래와 같이 연결되어 있습니다.
                    - 경기남부: 경기북부, 서울, 인천, 강원도, 경상북도, 대전, 대구
                    - 대전: 충청남도, 충청북도, 세종, 전라북도, 광주, 전라남도, 경기남부, 대구
                    - 대구: 경상북도, 경상남도, 부산, 울산, 경상북도, 경기남부, 대전
                    - 경상북도: 경기남부, 대구
                - 효율적으로 배송하기 위한 전체 경로를 결정하는 알고리즘을 구현해 보시기 바랍니다 (e.g., 다익스트라 알고리즘를 사용하여 최단거리나 최소시간이 소요되는 경로 탐색).
    - [ ]  허브 간 이동 경로 정보는 자주 변하지 않는 데이터입니다. 이 정보를 캐싱하여, API 호출 빈도를 줄이고 빠르게 조회 될수 있도록 해주세요.
    - [ ]  허브간 이동정보 엔티티의 deleted_by, deleted_at 필드를 이용하여 논리적 삭제를 관리합니다. 허브가 삭제될 때 연관된 이동정보도 삭제 관련 필드를 통해 비 활성화합니다.
    - [ ]  모든 조회 및 검색에서 deleted_at 필드가 null인 데이터만을 대상으로 처리하도록 합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | X | X | X | O |
        | `배송 담당자` | X | X | X | O |
        | `업체 담당자` | X | X | X | O |
        - **생성, 수정, 삭제**: 마스터 관리자 또는 스케줄러만 가능
        - **조회 및 검색**: 모든 로그인 사용자가 가능
- 배송담당자 관리
    - [ ]  배송담당자 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 소속 허브 ID, slack ID, 배송담당자 타입(허브 배송 담당자, 업체 배송 담당자), 배송 순번
        - **"slack ID" 는 사용자관리 엔티티에서 관리될 수도 있습니다**
        - [ ]  타입이 허브 배송 담당자일 경우, 소속 허브 ID를 어떻게 해야할까요?
        - [ ]  배송 담당자의 ID는 사용자 관리 엔티티의 사용자와 동일해야 합니다.(사용자 중에 배송 담담자가 있습니다.)
    - [ ]  배송 담당자가 추가 수정될때는 다음의 사항이 확인되어야 합니다.
        - [ ]  배송담당자 타입이 업체 배송 담당자인 경우*,* 소속 허브ID가 **존재하는 허브인지 확인합니다.
    - [ ]  배송 담당자는 순차적으로 배정됩니다.
        - [ ]  배송담당자는 배송담당자 엔티티의 배송순번을 기준으로 순차적으로 배정합니다. 
        `(배송순번 0 담당자 → 배송순번 1 담당자 → ... 배송순번 10 담당자 -> 배송순번 0 담당자)`
        - [ ]  새로운 배송 담당자가 추가되면 가장 마지막 순번으로 설정합니다.
        - [ ]  삭제된 담당자의 배송 순번은 재 배열되지 않습니다.
    - [ ]  엔티티의 CRUD + Search를 구현해 주세요.
    - [ ]  배송담당자 엔티티의 deleted_at, deleted_by 필드를 이용하여 논리적 삭제를 관리합니다. 허브 정보가 삭제되거나 변경될 때, 해당 배송담당자 데이터도 삭제 관련 필드를 통해 관리합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | O (담당 허브) | O (담당 허브) | O (담당 허브) | O (담당 허브) |
        | `배송 담당자` | X | X | X | O (본인 정보) |
        | `업체 담당자` | X | X | X | X |
        - **마스터**: 모든 권한
        - **허브 관리자**: 본인 허브에 소속된 배송 담당자만 관리 가능
        - **배송 담당자 본인**: 자신의 정보만 확인 가능
        - **업체 담당자**: 해당 엔티티에 접근 권한 없음
- 업체 관리
    - [ ]  업체 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 업체명, 업체 타입(생산업체, 수령업체), 업체 관리 허브 ID, 업체 주소
    - [ ]  엔티티의 CRUD + Search를 구현해 주세요.
    - [ ]  업체가 추가, 수정될때는 다음의 사항이 확인되어야 합니다.
        - [ ]  관리 허브ID가 존재하는 허브인지 확인합니다.
    - [ ]  업체 엔티티에 deleted_at, deleted_by 필드를 이용하여 논리적 삭제를 관리합니다. 업체가 삭제될 경우 관련된 서비스에서 연관 데이터를 비 활성화할 때 삭제 관련 필드를 기준으로 처리합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | O (담당 허브) | O (담당 허브) | O (담당 허브) | O |
        | `배송 담당자` | X | X | X | O |
        | `업체 담당자` | X | O (본인 업체) | X | O |
        - **마스터**: 모든 권한
        - **허브 관리자**: 자신의 허브에 소속된 업체만 관리 가능
        - **업체 담당자:** 자신의 업체만 수정 가능, 다른 업체의 읽기와 검색만 가능
- 상품 관리
    - [ ]  상품 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 상품명, 업체 ID, 상품 관리 허브 ID
        - **"상품 관리 허브 ID"는  업체관리 엔티티에서 관리될 수도 있습니다**
    - [ ]  엔티티의 CRUD + Search를 구현해 주세요.
    - [ ]  상품 생성시에 다음이 확인되어야 합니다.
        - [ ]  상품 업체가 존재하는지 확인합니다.
        - [ ]  상품 관리 허브 ID를 확인하여 존재하는지 확인합니다.
    - [ ]  상품 엔티티의 deleted_at, deleted_by 필드를 이용하여 논리적 삭제를 관리합니다. 상품이 삭제될 때 연관된 데이터(주문 등)도 삭제 관련 필드를 통해 관리합니다.
    - [ ]  모든 조회 및 검색에서 deleted_at 필드가 null인 데이터만을 대상으로 처리하도록 합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | O (담당 허브) | O (담당 허브) | O (담당 허브) | O (담당 허브) |
        | `배송 담당자` | X | X | X | O |
        | `업체 담당자` | O (본인 업체) | O (본인 업체) | X | O |
        - **마스터**: 모든 권한
        - **허브 관리자**: 자신의 허브에 소속된 상품만 관리 가능
        - **업체 담당자**: 자신의 업체의 상품만 생성 및 수정 가능
        - **배송 담당자**: 읽기와 검색만 가능
- 주문 관리
    - [ ]  주문 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 요청업체 ID(공급업체), 수령 업체 ID, 상품 ID, 수량, 배송 ID, 요청사항(납품기한 일자 및 시간 등)
    - [ ]  주문이 생성되면 배송도 같이 생성되어야합니다
    - [ ]  주문 엔티티의 deleted_at, deleted_by 필드를 이용하여 논리적 삭제를 관리합니다. 주문이 취소되거나 삭제될 때 연관된 데이터도 삭제 관련 필드를 통해 관리합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | O | O (담당 허브) | O (담당 허브) | O (담당 허브) |
        | `배송 담당자` | O | X | X | O (본인 주문) |
        | `업체 담당자` | O  | X | X | O (본인 주문) |
        - **생성**: 모든 로그인 사용자 (주문자) 가능
        - **수정**: 마스터 관리자와 해당 주문과 허브 관리자만 가능
        - **조회 및 검색**: 모든 로그인 사용자가 가능, 단, 주문자 본인은 자신의 주문만 조회 가능
- 배송 관리
    - [ ]  배송과 배송 경로 기록 엔티티를 생성해주세요. 필수 정보는 다음과 같습니다.
        - 배송
            - 주문에 대한 배송 전반의 상태와 관련된 정보를 관리합니다. 배송이 시작된 시점부터 완료될 때까지의 **전체적인 흐름**을 기록합니다.
            - **필수 정보:** 주문 ID, 현재상태(허브 대기중, 허브 이동중, 목적지 허브 도착, 배송중, 업체이동중, 배송완료 등), 출발 허브 ID, 목적지 허브 ID, 배송지 주소, 수령인, 수령인 슬랙 ID(전화번호 대체), **업체배송담당자 ID**
        - 배송 경로 기록
            - **배송 과정에서 발생한 각 경로**를 추적합니다. 각 허브 간의 이동 정보를 기록하여, 배송이 시작된 출발 허브에서 목적지 허브 까지의 경로 및 이동 상황을 추적합니다.
            - **필수 정보:** 배송 ID, 시퀀스(배송 경로 상 허브의 순번), 출발 허브 ID, 도착 허브 ID, 예상거리, 예상 소요시간, 실제 거리, 실제 소요 시간, 현재상태(허브 이동 대기중, 허브 이동중, 목적지 허브 도착, 배송중 등), **배송 담당자 ID**
        
        최종 허브에서 도착 업체까지의 배송 경로 기록은 별도의 엔티티로 만들지 않고, 
        배송 엔티티의 현재 상태(”업체 이동 중” → “배송 완료”) 를 활용하여 추적할 수 있습니다.
        
    - [ ]  주문이 생성될때 배송과 배송 경로 기록 데이터가 같이 생성되어야 합니다.
    - [ ]  배송 경로는 최초에 모든 경로가 생성되어야 합니다.
    - [ ]  배송 및 배송 경로 기록 엔티티의 deleted_at, deleted_by 필드를 추가하여 논리적 삭제를 관리합니다. 배송과 관련된 모든 데이터에서 삭제 관련 필드를 기준으로 비 활성화된 데이터를 관리합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성 (주문 시 자동 생성) | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | X  | O (담당 허브) | O (담당 허브) | O (담당 허브) |
        | `배송 담당자` | X | O (본인 배송) | X | O (본인 배송) |
        | `업체 담당자` | X | X | X | O |
        - **생성**: 주문 생성 시 자동으로 생성
        - **수정**: 마스터 관리자, 해당 허브 관리자, 그리고 해당 배송 담당자만 가능
        - **조회 및 검색**: 모든 로그인 사용자가 가능, 단 배송 담당자는 자신이 담당하는 배송만 조회 가능
    
- 슬랙 메시지 관리
    - [ ]  슬랙 메시지를 저장하는 엔티티를 생성합니다. 필수 정보는 다음과 같습니다.
        - 수신 ID, 메시지, 발송 시간등
    - [ ]  슬랙 앱을 생성하고 API를 통해 메시지 발송 기능을 구현합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        - 로그인한 모든 사용자 및 내부 시스템은 발송 가능
        
        |  | 생성 | 수정 | 삭제 | 조회 및 검색 |
        | --- | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O | O |
        | `허브 관리자`  | O | X  | X | X |
        | `배송 담당자` | O | X | X | X |
        | `업체 담당자` | O  | X | X | X |
- 사용자 관리
    - [ ]  사용자 엔티티는 모든 사용자 정보를 관리합니다.
    - [ ]  또한 다음의 권한으로 나누어 집니다.
        - 마스터 관리자
        - 허브 관리자
        - 배송 담당자
        - 업체 담당자
    - [ ]  회원가입 기능 (승인 기반 프로세스)
        - [ ]  이용자는 **회원가입 요청**을 통해 가입을 신청합니다.
            - [ ]  요청 시 필수 입력 정보:
                - 이름
                - 패스워드
                - SlackID
                - 소속 업체명 (또는 허브명)
            - [ ]  username은  `최소 4자 이상, 10자 이하이며 알파벳 소문자(a~z), 숫자(0~9)`로 구성
            - [ ]  password는  `최소 8자 이상, 15자 이하이며 알파벳 대소문자(a~z, A~Z), 숫자(0~9), 특수문자`
        - [ ]  회원가입 요청 후, 상태는 `PENDING` (승인 대기) 으로 저장합니다.
        - [ ]  마스터 관리자 또는 허브 관리자가 가입 요청을 검토 후 승인(`APPROVE`) 또는 거절(`REJECTED`)할 수 있습니다.
        - [ ]  승인 시 계정이 활성화되어 로그인할 수 있습니다.
    - [ ]  로그인 기능
        - [ ]  승인된 사용자(`APPROVED` 상태)만 로그인할 수 있습니다.
        - [ ]  유저 아이디와 패스워드를 입력받아 로그인을 진행합니다.
        - [ ]  로그인 성공 시, 로그인에 성공한 유저의 정보와 JWT를 활용하여 토큰을 발급합니다.
        - [ ]  발급한 토큰을 사용하여 사용자 정보를 조회 해봅니다.
    - [ ]  사용자 엔티티의 deleted_at, deleted_by 필드를 이용하여 논리적 삭제를 관리합니다. 사용자가 삭제되거나 비활성화될 때 삭제 관련 필드를 통해 처리합니다.
    - [ ]  권한 관리는 아래와 같습니다.
        
        
        |  | 생성, 수정, 삭제 | 회원가입, 로그인 | 조회 및 검색 |
        | --- | --- | --- | --- |
        | `마스터 관리자` | O | O | O |
        | `허브 관리자`  | X  | O | O (본인) |
        | `배송 담당자` | X | O | O (본인) |
        | `업체 담당자` | X | O | O (본인) |
        - 회원가입 요청: 모든 사용자 접근 가능
        - 회원가입 승인/거절: 마스터 관리자, 허브 관리자만 가능
        - 로그인: 승인된 사용자만 가능
        - ~~회원가입, 로그인 : 모두 접근 가능~~
        - **생성, 수정, 삭제**: 마스터 관리자만 가능
        - **조회 및 검색**: 사용자 본인만 자신의 정보를 조회 가능, 마스터 관리자는 모든 사용자 정보 조회 가능
- AI 연동 기능
    - [ ]  발송 허브 담당자에게 배송 예상 시간 알림 처리
    (물류를 요청한 업체에서 원하는 시간에 도착할 수 있도록 언제 발송을 해야할 지, 발송 허브 쪽 담당자가 확인하는 용도의 정보 제공)
        - [ ]  생성형 AI의 API로 최종 발송 시한을 포함한 정보를 생성해주세요.
            
            요청 시 AI에 전달할 데이터들 
            
            - 상품 및 수량 정보 등
            - 주문 요청 사항 (납기일자 및 시간 등)
            - 발송지, 경유지, 도착지 정보
            - 배송 담당자 근무시간 ( 09 - 18 )
            
            AI 응답에 포함 되어야 하는 데이터들
            
            - 요청 정보를 모두 고려하여 이 때까진 보내야 납기에 맞출 수 있다 하는 마지막 시점. 즉, 최종 발송 시한
            
            ※ 생성형 AI에 요청 시 관련 정보를 추가로 정리해 달라고 하셔도 되고, 최종 발송 시한 정보만 가져와도 됩니다.
            
        - [ ]  주문이 발생한 시점에 슬랙을 통해서 발송 허브 담당자에게 생성된 메시지를 보내서 알려주세요.
        (슬랙 API KEY를 여러개 쓰기 어려울 경우, 하나의 API KEY를 이용하여 처리)
        
        > **전달 메시지 예시**
        
        주문 번호 : 1
        ****주문자 정보 : 김말숙 / msk@seafood.world
        주문 시간 : 2025-12-08 10:00:00
        ****상품 정보 : 마른 오징어 50박스
        요청 사항 : 12월 12일 3시까지는 보내주세요!
        발송지 : 경기 북부 센터
        경유지 : 대전광역시 센터, 부산광역시 센터
        도착지 : 부산시 사하구 낙동대로 1번길 1 해산물월드
        배송담당자 : 고길동 / kdk@sparta.world
        
        위 내용을 기반으로 도출된 최종 발송 시한은 12월 10일 오전 9시 입니다.
        > 
        
- **기타 공통 사항**
    - [ ]  서치에는 검색조건 및 정렬기능이 추가되어 있어야 합니다.
        - [ ]  정렬기능은 기본적으로 생성일순, 수정일순을 기준으로 합니다.
    - [ ]  서치 기능에는 10건, 30건, 50건 기준으로 페이지에 노출 될수 있습니다. 이외의 건수는 제한하여 기본 10건씩으로 고정합니다.
    - [ ]  DELETE 호출이 발생하면 각 서비스에서 물리적인 삭제 대신 deleted_at, deleted_by 필드를 이용하여 데이터의 논리적 삭제(Soft delete)를 수행합니다.
    - [ ]  모든 엔티티에 deleted_at, deleted_by 필드를 추가하여 논리적 삭제를 관리하며, 해당 필드를 통해 삭제되지 않은 데이터만 조회 및 검색 할 수 있도록 로직을 구현합니다.
    - [ ]  트랜잭션 처리 시, 논리적 삭제에 대한 예외 상황도 고려하여 롤백 등의 처리를 구현합니다.
    - [ ]  MSA 환경에서 API 호출 기반으로 서비스 간 데이터 연관성을 유지하기 위해, 각 서비스 간에 필요한 연관 데이터를 처리하는 API를 제공하고, 데이터 변경 시 이를 즉시 반영할 수 있도록 서비스 간 통신을 설계해야 합니다.
    - [ ]  API 호출을 통해 서비스 간 데이터 동기화를 수행할 때, 실패 시 재시도 로직을 구현하여 통신의 신뢰성을 확보해야 합니다.
    - [ ]  서비스 간 데이터 일관성을 유지하기 위해 추가적인 로직을 구현해야 합니다.
    - [ ]  여러 개의 엔티티가 동시에 업데이트되거나 생성되는 경우 트랜잭션 처리를 구현해야 합니다. 예를 들어, 주문이 생성되면서 배송이 함께 관리될 때, 하나라도 실패하면 전체를 롤백하는 기능이 필요합니다.
    - [ ]  테이블 명세서를 작성해주세요.
    - [ ]  https://app.diagrams.net/ 또는 https://dbdiagram.io/을 통해 ERD를 만들어주세요.
    - [ ]  https://app.diagrams.net/ 를 사용하여 인프라의 설계도를 작성해주세요.
    - [ ]  Swagger등의 API 문서 자동화 라이브러리를 적용하고 API 문서를 현행화 합니다.
        - 마이크로 서비스별로 문서화 하는것이 기본입니다.
        - 게이트웨이를 통해 각 마이크로서비스의 문서를 전부 볼 수 있게 해주시면 베스트입니다.
    - [ ]  모든 서비스에 Zipkin을 사용하여 분산 추적을 가능하게 해주세요.
    

## 5️⃣ 도전 기능 가이드

- [ ]  서비스 간 호출을 메시징 시스템으로 전환하기
(모든 부분을 전환할 필요는 없습니다. 일부분만 선택하여 전환해봅니다.)
    - [ ]  메시징 시스템 종류는 다양하며 대표적으로 Kafka와 RabbitMQ가 있습니다. 이외에도 다양한 메시징 시스템 중, 원하는 시스템을 선택해보세요.
    - [ ]  기존의 API 호출 기반 서비스 간 통신을 메시징 시스템으로 전환합니다.
    - [ ]  메시징 시스템을 사용하여 각 서비스 간 비 동기적으로 메시지를 전송하고, 이벤트 기반 통신을 구현합니다.
    - [ ]  각 서비스에서 필요한 큐를 설정하고, 메시지 송수신 로직을 구현하여 데이터의 일관성과 신뢰성을 확보합니다.
    - [ ]  메시징 시스템을 사용하여 서비스 간의 느슨한 결합을 유지하면서도 확장성과 유연성을 강화할 수 있습니다.
    - [ ]  기존 API 호출에 대한 로직은 필요 시 백업으로 유지하거나, 메시징 시스템 기반으로 대체합니다.
    - [ ]  **MSA에서 적용 해볼만한 곳을 파악해보시고 메시징 시스템으로 전환해보세요 (MSA 서비스 간 연계, 슬랙 메시지 발송 등등).**

- [ ]  매일 업체 배송담당자에게 아침 6시 슬랙 알림을 발송해주세요.
    - [ ]  업체 배송담당자가 당일 방문해야 하는 주소들의 위경도 값을 AI를 통해, 배송 순서를 지정해주세요.
    - [ ]  결과 경유지 순서를 사용하여 네이버 경로 API의 waypoints 파라미터를 사용하여 결과를 받아주세요.
        - [ ]  네이버 Map API 중 **Directions 5 API** 연동을 구현해주세요.(https://api.ncloud-docs.com/docs/ai-naver-mapsdirections-driving)
        - [ ]  경로 API는 위도와 경도 값으로 출발지와 도착지를 입력합니다. 다른 API를 사용하여 이름을 통해 위도 경도를 입력할 수 있지만 google 맵에서 검색하면 주소에 위경도 값이 나옵니다.
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/83c75a39-3aba-4ba4-a792-7aefe4b07895/9df5fb14-f829-43f7-bd0d-6de467389a92/image.png)
        
    
    - [ ]  해당 방문 순서를 포함한 경로 및 시간 데이터를 포함하여 AI를 통해 메시지를 생성하여 슬랙으로 발송해주세요.
    - [ ]  구현과 테스트 편의성을 위해 발송 시각을 설정파일에서 관리하고 수정할 수 있게 해주세요.
    - [ ]  업체 배송경로 기록 엔티티를 추가해주세요. 엔티티는 배송ID, 출발허브ID, 수령업체, 예상거리, 예상소요시간, 실제거리, 실제 소요시간, 현재상태(업체 이동중, 배송완료 등), 배송 담당자ID, 배송순서 정도를 포함해주세요. 추가적으로 필요하다고 판단되는 필드가 있다면, 자유롭게 추가해주셔도 됩니다.
- [ ]  배송 담당자 배정 로직을 자유롭게 구현해주세요.
    - [ ]  허브 배송 담당자, 업체 배송 담당자가 효율적으로 배송을 완수하기 위한 구현을 해주세요.
    - [ ]  제한사항은 없습니다. 필요한 로직과 정책을 총동원 해주세요!
    - [ ]  예시) 거리를 기반으로 한 효율적인 담당자 배정