# 2차 프로젝트 도움말

## 1. MSA의 인증/인가 구현

### 1.1 모놀리식 구조의 인증/인가 원리

모놀리식 애플리케이션은 모든 요청이 **단일 Servlet Context**와 **공통 필터 체인**을 거친다.
`SecurityContextHolder`는 `ThreadLocal` 기반으로 동작하며, 모든 도메인에서 동일한 인증 정보를 참조할 수 있다.

---

### 1.2 MSA 구조의 특성

* 각 도메인은 **별도 Spring 애플리케이션**으로 독립 실행
* `ApplicationContext`와 `SecurityContext`가 공유되지 않음
* 인증 정보는 각 서비스 간 **직접 전파되지 않음**
* 따라서 **공통 인증 수단** 또는 **서비스별 인증 로직**이 필요

---

### 1.3 MSA 환경의 요청 흐름

1. 사용자의 요청 → **API Gateway** 진입
2. Gateway → 도메인 서비스로 라우팅
3. `Auth` 서비스는 별도 위치에 있으므로, 모든 요청을 필터링할 수 없음
4. 따라서 `Auth`만으로 전체 서비스의 보안을 보장할 수 없음

---

### 1.4 MSA 인증/인가 구현 방식

| 방식                       | 개요                                        | 장점           | 단점                |
| ------------------------ | ----------------------------------------- | ------------ | ----------------- |
| **(1) 서비스별 Security 적용** | 각 서비스가 JWT를 파싱해 Header의 `userId`를 기반으로 인증 | 독립성, 세밀한 제어  | 설정 중복, 유지보수 비용    |
| **(2) Gateway 인증 통합**    | Gateway가 인증을 처리하고 Header에 사용자 정보를 삽입      | 인증 중앙화, 단순화  | 설정 복잡도, 트래픽 병목 위험 |
| **(3) 수동 인증 처리**         | 서비스 로직 내에서 JWT 검증 및 유저 서비스 호출             | 필터 제거로 성능 향상 | 일관성 저하, 중복 코드 발생  |

**결론:**
특정 방식이 “정답”은 아니며, **팀의 보안 정책·개발 속도·운영 복잡도**에 따라 선택이 달라진다.

---

## 2. DDD 패키지 구조 설명

### 2.1 Repository 분리 이유

#### (1) 구조 비교

| 구분                    | 설명                         | 소속 계층                    |
| --------------------- | -------------------------- | ------------------------ |
| `OrderRepository`     | 도메인 개념의 추상화 (순수한 비즈니스 언어)  | **Domain Layer**         |
| `JpaOrderRepository`  | JPA 기반 데이터 접근 구현체          | **Infrastructure Layer** |
| `OrderRepositoryImpl` | 도메인 인터페이스를 기술 구현과 연결하는 어댑터 | **Infrastructure Layer** |

#### (2) 목적

* 도메인이 특정 기술(JPA, MyBatis 등)에 의존하지 않도록 **추상화 계층** 분리
* QueryDSL, CQRS 등 확장 기술 도입 시 유연성 확보

---

### 2.2 DTO가 두 계층에 존재하는 이유

| 구분                   | 역할                 | 특징         |
| -------------------- | ------------------ | ---------- |
| **Application DTO**  | 내부 유스케이스 처리용 안정 구조 | 비즈니스 로직 중심 |
| **Presentation DTO** | 클라이언트 요청/응답 가공용    | UI 요구사항 중심 |

* 예: 내부 호출에는 `id` 포함, 외부 응답에는 `id` 제외 등의 요구 대응
* SRP(단일 책임 원칙) 준수
* 단일 클라이언트만 존재 시 Presentation DTO는 생략 가능

---

### 2.3 도메인 서비스 vs 애플리케이션 서비스

| 구분                                   | 정의                     | 역할               | 예시                       |
| ------------------------------------ | ---------------------- | ---------------- | ------------------------ |
| **도메인 서비스 (Domain Service)**         | 엔티티에 속하지 않는 비즈니스 규칙 담당 | 여러 애그리거트 간 협력 표현 | 송금 시 2개의 `Account` 협력 로직 |
| **애플리케이션 서비스 (Application Service)** | 도메인 로직 조합 및 실행 순서 관리   | 유스케이스 수행         | “송금 요청 처리” 전체 흐름 제어      |

* 하나의 애그리거트로 해결 가능한 규칙은 **도메인 서비스로 분리하지 않음**
* 도메인 서비스는 **협력 로직을 표현하는 조력자**
* 애플리케이션 서비스는 **유스케이스 실행자**

---

## 3. 결론

DDD와 MSA 구조는 **추상화·확장성·책임 분리**를 위한 도구이며,
모든 프로젝트에 동일하게 적용해야 하는 규칙이 아니다.

> 팀의 규모, 복잡도, 개발 속도에 따라 계층을 단순화하거나 생략하는 것도 합리적 선택이다.
> 중요한 것은 **“왜 이 구조를 선택했는가”**에 대한 명확한 합의와 일관성이다.

---

### 참고

출처: `tutorialDDDandMSAAuth.pptx`
